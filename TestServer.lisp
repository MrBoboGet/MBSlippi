;(setf test (make-string 10))
;(read-sequence test *standard-input*)
;(write-sequence (make-string 100) *standard-output*)
;(quit)
;(prin1 "befbin")
;#-quicklisp
(let ((quicklisp-init (merge-pathnames "quicklisp\\setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))
(ql:quickload "yason" :silent t)
;(prin1 "befbin")
(defun parse-binary-integer (stream-input int-size)
   (let ((result 0) (data (make-list int-size)))
       (read-sequence data stream-input)
       (setf data (mapcar #'char-int data))
       (dotimes (i int-size)
          (incf result (ash (nth i data) (* (- int-size i 1) 8)))
          )
       (eval result)
   )
)
(defun write-binary-integer (target-stream  integer-to-write int-size)
    (let ((data-to-write (list)))
      (dotimes (i int-size)
        (setf data-to-write (append data-to-write (list (ldb (byte 8 (* i 8)) integer-to-write))))
      )
      (setf data-to-write (reverse data-to-write))
      (write-sequence (mapcar #'code-char data-to-write) target-stream)
    )
)

(defun parse-gqp-message (stream-input)
    (let ((message-size 0) (message "") (data ""))
        ;(prin1 "befbin")
        (setf message-size (parse-binary-integer stream-input 4))
        (setf data (make-string message-size))
        (read-sequence data *standard-input*)
        (setf message (yason:parse data))
        ;(with-open-file (s "TestLispOutput.txt" :direction :output :if-exists :supersede)
        ;  (yason:encode message s))
    )
)

;(parse-gqp-message *standard-input*)

(defun json-to-string (json-object)
  (yason:with-output-to-string* () (yason:encode json-object))
)

(defmacro hash-table* (&body body)
  (setf hash-sym (gensym))
  (setf result-body (loop for part in body collect
    `(setf (gethash ,(nth 0 part) ,hash-sym) ,(nth 1 part)))
  )
  (setf result `(let ((,hash-sym 0)) (setf ,hash-sym (make-hash-table :test 'equal)) ,@result-body (eval ,hash-sym)))
)

(defparameter *filter-names* (make-hash-table))
;(setf (gethash "Test" *filter-names*) "test")
;(print (hash-table-count *filter-names*))
;(maphash (lambda (key func) (print key)) *filter-names*)

(defun send-gqp-message (json-to-send)
  (let* ((string-to-send (json-to-string json-to-send)) (message-length (length string-to-send)))
    (write-binary-integer *standard-output* message-length 4)
    (write-sequence string-to-send *standard-output*)
  )
)

(defun create-error-response (error-message)
  (hash-table* ("error" error-message))
)
(defun create-response (result-body) 
  (hash-table* ("result" result-body))
)
(defun hash-keys (hash-table)
  (loop for key being the hash-keys of hash-table collect key))
(defun create-init-response () 
  (create-response (hash-table* 
                            ("version" "0.1.0")
                            ("filters" (mapcar (lambda (name) (hash-table* ("name" name))) (hash-keys *filter-names*)))
                         )
                )
)
(defun create-filter-response (intervalls)
    (create-response (hash-table* ("intervalls" intervalls)))
)

(defmacro def-filter (name (arg1) &body body)
  `(setf (gethash ,name *filter-names*) (lambda (,arg1) ,@body))
)

(defun exctract-sequences (total-sequence predicate)
  (let ((result (list)) (wastrue NIL) (first-true 0) (i 0))
    (dolist (current-element total-sequence)
      (progn
      (if (funcall predicate current-element)
        (progn
          (if (not wastrue) (first-true i))
          (setf wastrue T)
        )
        ;else
        (progn
          (if (wastrue)
            (progn
             (setf result (append result (list first-true (- i 1))))
             (setf wastrue NIL)
            )
          )
        )
      )
      (incf i)
      )
    )
    (list* result)
  )
)
(def-filter "HasDair" (frames) 
  (exctract-sequences frames (lambda (frame) (equal (gethash "activeAttack" (nth 1 frame)) "Dair")))
)

(defun handle-request (request) 
    (handler-case  (let ((request-method (gethash "method" request)))
        (if (equal request-method "ExecuteFilter") 
          (let* ((params (gethash "params" request)) (filter-name (gethash "filterName" (params))))
            (let ((handler (gethash filter-name *filter-names*))) 
                (if (handler) 
                  (send-gqp-message (create-filter-response (funcall handler (gethash "frames" params))))
                  (send-gqp-message (create-error-response "No filer with name"))
            ))
          )
        ;else
          (send-gqp-message (create-error-response "Unsupported method"))))
        ;errors        

        (error (e) (send-gqp-message (create-error-response "Error parsing message")))
      ))

(defun main ()
    (setf init-message (parse-gqp-message *standard-input*))
    (send-gqp-message (create-init-response))
    (loop while (list* T) do (handle-request (parse-gqp-message *standard-input*)))
    (quit)
)
